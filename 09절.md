## 9.1 Priority Queue
우선순위에 따라 출력해주고 싶을때 우선순위 큐를 두가지 구조로 생각해볼 수 있다.
1. 입력을 할때 줄을 세워서 큐를 만든다. → 새로운 요소가 들어올때, 자기에게 맞는 자리를 찾아서 들어가도록 한다.
2. 출력해줄때 우선순위가 높은 element 를 찾아서 출력해준다.

우선순위를 나타내기 위한 key 를 정의해주고 key value 페어를 저장하면 된다.

## 9.2 List 를 이용한 우선순위 큐 구현
linked list 에서 다음 노드와 이전 노드를 지정해주는 포인터가 있었으니, 이 구조를 이용해서 만들어보자

Unsorted 구조로 정의한 우선순위 큐
- 삽입 method 는 O(1)
- 가장 작은 키값을 찾기 위한 method 는 O(n)

Sorted 구조
- 삽입 method O(n)
- 가장 작은 키값을 찾는 method O(1)

어떤 구조를 사용할 것인지는 응용의 특징에 따라서 골라주면 된다. → 삽입을 많이 하는지, 값을 빼는 것을 많이 하는지

Unsorted / Sorted 는 서로 너무 극단적인 특징을 가지고 있음. 값을 삽입할때도 O(1) ~ O(n) 사이의 시간복잡도를 가지고, 값을 뺄때도 O(1) ~ O(n) 사이의 시간 복잡도를 가지고 싶은 경우 → 이 경우는 O(log n) 의 시간 복잡도를 갖는 경우를 의미하는구나, 그리고 Tree 구조를 떠올리면 좋을 것 같다.

## 9.3  Heaps
heap 이라는 자료구조는 이진트리인데, 두가지 성질을 만족해야함
- Relational Property (Heap - order Property)
힙을 구성하는 아이템들 사이의 순서가 있다는 것. 가장 작은 key를 가진 아이템이 heap 의 top 에 위치해야한다.
노드의 키는 자식 노드보다 작거나 같아야한다.
- Structual Property
트리는 complete 해야한다는 제약조건. 트리의 맨 마지막 level 을 제외한 level 은 모두 포화 이진트리여야한다. (height 가 h 면, 0~h-1 level 이 꽉 차 있어야한다.)
그리고 마지막 레벨의 노드들은 왼쪽부터 오른쪽 순으로 차있어야한다.

그리고 Heap 의 조건들로 하여금 height 를 노드의 갯수로 표현할 수 있다.
이제 heap 을 이용하면 노드를 삽입하거나 삭제할때, O(h) = O(log n) 을 보장해줄 수 있다. 

이제 새로운 노드를 넣는 상황을 생각해보자
1. 일단 높이 h 의 가장 오른쪽 위치에 넣어준다. - 이때, 꽉 차 있으면 h+1 로 새로운 레벨을 만들어줘야한다. → heap 의 structual property 를 만족
2. 그리고 노드의 key 값을 토대로 root 노드까지 쭉쭉 올라가면서 올바른 위치로 노드를 옮겨준다. 그리고 이 과정을 bubbling 이라고 한다. → relational property 만족 

그럼 위 과정을 통해서 ADD 했을때의 worst case 는 맨 밑 level 에서 root까지 가는 경우 → O(h) = O(log n)
위로 올라갈수록 탐색할 필요가 없는 부분이 생겨남 → log n  을 떠올려라

remove 를 살펴보면, 가장 키 값이 작은 것이 우선순위가 높은 것으로 가정하기 때문에 root 를 romove_min 을 하면 root 를 뽑아내는게 된다. → heap 의 트리 구조가 무너짐
어떻게 다시 구조를 맞추던지 상관없지만 가장 편하게 restructur 하는 방법은 바텀의 가장 오른쪽, 즉 height 레벨의 가장 오른쪽 끝 노드를 root 로 가져오는 방법
이제, heap order property 를 만족시키기 위해서 root로 옮겨진 노드의 위치를 bubbling 해줘야함 - KEY > LK,RK 를 만족할때까지
1. 바이너리 트리이기 때문에 루트로 올라간 node 는 두 자식을 가지고 있을것이고, 각각이 key 를 가지고 있다. - RK, LK 라고 칭하면
2. RK 와 LK 중 더 작은 키 값과 자리를 바꿔주고, KEY >= LK,RK 를 만족할때까지 위 과정을 반복

Array 를 이용해서 heap 을 구현하는 방법
0번 인덱스 - root
1,2번 인덱스 - root의 LC / RC
3,4번 인덱스 - LC 의 LC/RC
5,6번 인덱스 - RC 의 LC/RC
...
값의 삽입시에는 그냥 배열의 맨 마지막에 넣어주면 된다. 그리고 이진트리 성질을 이용해 부모의 인덱스값을 찾아서 key 를 비교해서 자신의 위치를 찾아가면 된다.

## 9.4 Sorting with a Priority Queue
1. Unsorted list 로 만드는 경우
remove_min 을 해줄때, 우선순위 순서를 생각해서 output 해주는 상황
삽입할때는 O(1) 에 시행할 수 있지만, n 개의 element 를 가지는 sequence C 를 sorting 된 상태로 출력하는 경우에는 n + n-1 + n-2 + ... + 1 → O(n^2) 의 시간복잡도를 가지게 된다.
2. Sorted list 로 만드는 경우
삽입하면서 sorting 하는 경우, 1+2+...+n → O(n^2)
각각의 정렬된 값들을 출력하는 시간복잡도는 O(1) 이기 때문에, 정렬된 시퀀스를 출력하는 시간복잡도는 O(n)
3. Heap-sort 로 만드는 경우
하나의 값에 대해 입력과 출력 모두 O(log n) 의 시간복잡도를 가지기 때문에 모든 값을 입력하고 출력하는 경우에 O( n log n) 의 시간복잡도를 가진다.

9.3 에서 했던 내용은 시퀀스 c 를 정렬하기 위해서는 새로운 공간을 확보해두고 1)그 공간에 값을 집어넣고 정렬된 상태로 출력하거나, 2) 일단 값을 집어넣고 출력을 정렬된 상태로 하거나 / 두 방법을 이용해서 다시 시퀀스 c 에 값들을 출력해주는 방식이었음
-> 즉 시퀀스를 정렬시키기 위해서 새로운 공간을 필요로 함, n만큼의 사이즈 공간이 2개를 필요로 한다.

### in-place 방식 → 새로운 공간 없이 시퀀스 c 내부에서 정렬을 하는 방식
배열 형태로 저장된 정수 sequence 를 in place 방식으로 heap sort 를 하는 과정
먼저, heap 을 배열로 구현을 할 수가 있다고 위에서 배움. 따라서 sequence 의 요소들을 heap 구조를 만족시킬 수 있도록 값들을 순차적으로 옮겨주면 된다. (만약 정수값이 클 수록 높은 우선순위를 갖는 경우라면)
1. 가장 큰 수를 찾아서 0번 인덱스 숫자와 자리 교체
2. 1,2번 인덱스가 0번 인덱스보다 작거나 같은지 확인
3. 3,4번 인덱스가 1번 인덱스보다 작거나 같은지 확인하고 더 크다면 서로 자리 교체
- 이때, 3번 인덱스와 1번 인덱스를 비교하고 / 4번 인덱스와 1번 인덱스를 비교하는 식으로 하나하나 비교해야한다. → 만약 3번이 1번 인덱스보다 크고 4번이 3번보다 큰 경우를 생각해보면 된다. → 첫번째 비교에서 3번과 1번이 바뀌고 두번째 비교에서 1번(원래 3번인덱스) 과 4번이 바뀌게 된다.
4. 위 과정을 반복

그럼 heap 으로 구성된 시퀀스의 원소들을 순서에 맞게 빼는 방법에 대해서 생각해보자
- root 에 가장 큰 값이 들어가 있지만, root 의 lc 와 rc 사이의 관계는 알 수가 없기 때문에 무엇을 빼줘야할지는 모르는 상황 → 그래서 맨밑 제일 오른쪽에 있는 노드를 root 로 올리고 자리를 찾아줌으로써 다시 가장 큰 값을 가지는 노드를 찾아내는 과정을 거쳐야함
- 그리고 in-place 방식에서는 값을 뽑아낸다는 개념보다는, 0번 인덱스와 n번 인덱스를 교체해주면 가장 큰 수를 뽑아낸 것처럼 된다.
1. 즉 첫번째 시행에서는 0번 인덱스와 n번 인덱스 값을 교환해주고, 0번째 인덱스의 위치를 적절한 위치로 옮겨주는 과정을 거친다. → 이 과정을 거치면 0~n-1 까지는 heap 구조를 만족하고 n번째는 가장 큰 수가 뽑혀져 나옴
2. 그리고 0번째와 n-1번째를 교환하고 0번째 인덱스의 위치를 적절한 위치로 옮겨주면 1과 동일하게 이제 n-1번째 인덱스에는 두번째로 큰 수가 뽑혀나온 효과를 갖는거고. 0~n-2 까지는 heap 구조를 만족하는 상태가 된다.
3. 위 과정을 0번째와 1번째 인덱스가 교체될때까지 반복
- 0번째 인덱스를 적절한 위치로 옮기는 방법은 위에서 bubbling 이라고 배웠다.
- 그리고 위 과정을 모두 거치면 오름차순으로 정렬한 것과 같은 효과를 얻을 수 있다.
- 메모리를 효율적으로 사용할 수 있다는 장점

## 9.5 Adaptable Priority Queues
우선순위를 변경이 가능하도록 구성하고 싶은 경우가 있을때 사용
즉 key 값을 변경이 가능하도록 구현하는 것, key 변경 자체는 쉽지만 변경 이후 heap 구조로 구현된 경우 key 변경으로 인해 구조에 영향을 주는 부분이 무엇인지에 대해서 생각해보아야한다.

배열 형태로 저장된 heap 구조가 있을때, root 노드가 지워지면서 맨 끝에 있던 노드가 root 로 올라오고 bubbling 과정을 거치면서 새로운 위치로 움직이게 됨
이 과정에서 다른 노드의 움직임으로 인해 index 에 영향을 받는 노드들이 존재함 → 루트로 올라온 노드가 적절한 경로를 따라 index 를 바꿔가면서 위치를 옮겨가게 될테니깐.
idea 는 배열에 저장되는 element 들은 메모리에 적재가 될테니, 그 메모리 주소를 기억하고 있는 Token 을 설정해두자는 것 → 검색을 편하게 하기 위해서
즉, root 노드가 빠져나갈때마다 index 값이 변하는 노드들이 존재 → index 라는 것은 특정 노드를 가리키기 위해서 사용하는 것이니깐, 노드의 위치가 바뀌더래도 메모리 주소 자체는 바뀌지 않으니깐 한 노드를 지칭할 수 있는 Locator = Token 을 설정하자는 개념이다. 즉, Token 을 이용하면 매번 달라지는 index 를 찾는 시간을 줄일 수가 있다.
- 여기서 Token이 값들의 메모리 주소를 지칭한다는 의미는 각 element 들이 index 를 멤버로 가지고 있겠다는 의미이다.
- 예를들어 A 라는 노드가 원래는 5번 index 에 들어있었는데, root 노드가 삭제됨에따라 n번째 노드가 root 로 올라오면서 restructure 과정에서 3번 인덱스로 옮겨졌다고 하면. A 라는 노드를 검색할 수 있는 방법은 A의 key 를 순차적으로 검색하는 방법 → 따라서 A노드가 자신이 몇번 index 에 속하는지에 대한 정보를 가지고 있으면, 두 노드의 위치를 바꿀때 index 값을 서로 바꿔주면 되는 것이고. 노드의 탐색에 있어서도 효율적으로 수행이 가능해진다.